package lab13.Drivers;import lab13.ADTPackage.LinkedStack;import lab13.ADTPackage.QueueInterface;import lab13.ADTPackage.StackInterface;import lab13.GraphPackage.BasicGraphInterface;import lab13.GraphPackage.UndirectedGraph;/**    A driver that demonstrates the class UndirectedGraph   and an unweighted graph.      @author Frank M. Carrano   @version 3.0*/public class DriverUU // undirected, unweighted{	private static UndirectedGraph<String> myGraph = new UndirectedGraph<String>();	private static StackInterface<String> path = new LinkedStack<String>();	private static final String A = "A";	private static final String B = "B";	private static final String C = "C";	private static final String D = "D";	private static final String E = "E";	private static final String F = "F";	private static final String G = "G";	private static final String H = "H";	private static final String I = "I";  	private static final String CS1  = "CS1";	private static final String CS2  = "CS2";	private static final String CS3  = "CS3";	private static final String CS4  = "CS4";	private static final String CS5  = "CS5";	private static final String CS6  = "CS6";	private static final String CS7  = "CS7";	private static final String CS8  = "CS8";	private static final String CS9  = "CS9";	private static final String CS10 = "CS10";	public static void main(String[] args)	{ 		setAndDisplayGraph();		testEdges();		testBFS(A);		System.out.println("A B D E C G F H I  Expected");		testDFS(A);		System.out.println("A B C F E H G D I  Expected");		testShortestPath(); // A - E - H		testExample28_26();		System.out.println("Done.");	}  // end main		public static void setAndDisplayGraph() 	{		setVerticesFig28_10(); // graph cleared before setting vertices		setEdgesFig28_10Undirected();			System.out.println("Testing an undirected, unweighted graph like the one in Figure 28-10, " +		                   "but without directions on its edges.");                  		myGraph.display();		} // end setAndDisplayGraph	public static void testEdges()	{		setVerticesFig28_10(); // graph cleared before setting vertices		setEdgesFig28_10Undirected();				System.out.println("\nNumber of vertices = " + myGraph.getNumberOfVertices() +		                   " (should be 9)");		System.out.println("Number of edges = " + myGraph.getNumberOfEdges() +		                   " (should be 13)");		// check existing edges			boolean ok = true;		ok = checkEdge(A, B, ok);			ok = checkEdge(A, D, ok);			ok = checkEdge(A, E, ok);			ok = checkEdge(B, E, ok);			ok = checkEdge(C, B, ok);		ok = checkEdge(D, G, ok);		ok = checkEdge(E, F, ok);		ok = checkEdge(E, H, ok);		ok = checkEdge(F, C, ok);			ok = checkEdge(F, H, ok);			ok = checkEdge(G, H, ok);			ok = checkEdge(H, I, ok);				// check some non-existing edges				ok = checkNoEdge(A, I, ok);		ok = checkNoEdge(C, E, ok);		ok = checkNoEdge(B, F, ok);		if (ok)			System.out.println("Edges are OK.");			} // end testEdges	private static boolean checkEdge(String vertex1, String vertex2, boolean ok)	{		boolean check = ok;		 	if (!myGraph.hasEdge(vertex1, vertex2))		 	{			System.out.println("hasEdge error " + vertex1 + " " + vertex2);			check = false;		} // end if			return check;	} // end checkEdge		private static boolean checkNoEdge(String vertex1, String vertex2, boolean ok)	{		boolean check = ok;		 	if (myGraph.hasEdge(vertex1, vertex2))		 	{			System.out.println("hasEdge error " + vertex1 + " " + vertex2);			check = false;		} // end if			return check;	} // end checkNoEdge	public static void testBFS(String v)	{		setVerticesFig28_10(); // graph cleared in setVertices		setEdgesFig28_10Undirected();			System.out.println("\n\nBreadth-First Traversal beginning at vertex " + v + ": ");		QueueInterface<String> bfs = myGraph.getBreadthFirstTraversal(v);				printQueue(bfs);	} // end testBFS		public static void testDFS(String v)	{		setVerticesFig28_10(); // graph cleared before setting vertices		setEdgesFig28_10Undirected();			System.out.println("\n\nDepth-First Traversal beginning at vertex " + v + ": ");		QueueInterface<String> dfs = myGraph.getDepthFirstTraversal(v);				printQueue(dfs);	} // end testDFS		public static void testShortestPath()	{		setVerticesFig28_10(); // graph cleared before setting vertices		setEdgesFig28_10Undirected();			System.out.println("\n\nFinding the shortest paths from vertex A:\n");				showPath(A, B);		showPath(A, C);		showPath(A, D);		showPath(A, E);		showPath(A, F);		showPath(A, G);		showPath(A, H);		showPath(A, I);	} // end testShortestPath	private static void showPath(String vertex1, String vertex2)	{		System.out.println("The shortest path from " + vertex1 + " to " + vertex2 + " is ");		int length = myGraph.getShortestPath(vertex1, vertex2, path);		printStack(path);		System.out.println("and has a length of " + length + ".");		System.out.println();	} // end showPath	public static void testExample28_26()	{		System.out.println("\n\nTesting Example 28.26 to create the graph in Figure 28-21:\n");		BasicGraphInterface<String> airMap = new UndirectedGraph<String>();		airMap.addVertex("Boston");		airMap.addVertex("Provincetown");		airMap.addVertex("Nantucket");		airMap.addEdge("Boston", "Provincetown");		airMap.addEdge("Boston", "Nantucket");		System.out.println("Number of vertices = " + airMap.getNumberOfVertices() +		                   " (should be 3)");		System.out.println("Number of edges = " + airMap.getNumberOfEdges() +		                   " (should be 2)");	} // end testExample28_26	private static void setVerticesFig28_08()	{				myGraph.clear();		myGraph.addVertex(CS1);		myGraph.addVertex(CS2);		myGraph.addVertex(CS3);		myGraph.addVertex(CS4);		myGraph.addVertex(CS5);		myGraph.addVertex(CS6);		myGraph.addVertex(CS7);		myGraph.addVertex(CS8);		myGraph.addVertex(CS9);		myGraph.addVertex(CS10);	} // end setVerticesFig28_08		private static void setEdgesFig28_08()	{		myGraph.addEdge(CS1, CS2);				myGraph.addEdge(CS2, CS3);		myGraph.addEdge(CS2, CS4);		myGraph.addEdge(CS2, CS5);				myGraph.addEdge(CS4, CS6);		myGraph.addEdge(CS4, CS7);				myGraph.addEdge(CS5, CS10);		myGraph.addEdge(CS6, CS8);		myGraph.addEdge(CS7, CS8);		myGraph.addEdge(CS7, CS9);				myGraph.addEdge(CS9, CS10);	} // end setEdgesFig28_08	private static void setVerticesFig28_10()	{				myGraph.clear();		myGraph.addVertex(A);		myGraph.addVertex(B);		myGraph.addVertex(C);		myGraph.addVertex(D);		myGraph.addVertex(E);		myGraph.addVertex(F);		myGraph.addVertex(G);		myGraph.addVertex(H);		myGraph.addVertex(I);	} // end setVerticesFig28_10		private static void setEdgesFig28_10Undirected()	{		myGraph.addEdge(A, B);		myGraph.addEdge(A, D);		myGraph.addEdge(A, E);				myGraph.addEdge(B, C);		myGraph.addEdge(B, E);				myGraph.addEdge(C, F);				myGraph.addEdge(D, G);		myGraph.addEdge(E, F);		myGraph.addEdge(E, H);				myGraph.addEdge(F, H);		myGraph.addEdge(F, I);				myGraph.addEdge(G, H);		myGraph.addEdge(H, I);		/* Since additions are made to the end of each edge list,    these lists appear as follows:		A: B -> D -> E		B: A -> C -> E		C: B -> F		D: A -> G		E: A -> B -> F -> H		F: C -> E -> H -> I		G: D -> H		H: E -> F -> G -> I		I: F -> H   We can predict the BFS and DFS traversals knowing this. */	} // end setEdgesFig28_10Undirected	private static void printStack(StackInterface<String> s)	{		while (!s.isEmpty())			System.out.print(s.pop() + " ");					assert(s.isEmpty());		System.out.println();	} // end printStack		private static void printQueue(QueueInterface<String> q)	{		while (!q.isEmpty())			System.out.print(q.dequeue() + " ");		System.out.println(" Actual");	} // end printQueue}  // end DriverUU/*Testing an undirected, unweighted graph like the one in Figure 28-10, but without directions on its edges.Graph has 9 vertices and 13 edges.Edges exist from the first vertex in each line to the other vertices in the line.(Edge weights are given; weights are zero for unweighted graphs):I F 0.0 H 0.0 H E 0.0 F 0.0 G 0.0 I 0.0 G D 0.0 H 0.0 F C 0.0 E 0.0 H 0.0 I 0.0 E A 0.0 B 0.0 F 0.0 H 0.0 D A 0.0 G 0.0 C B 0.0 F 0.0 B A 0.0 C 0.0 E 0.0 A B 0.0 D 0.0 E 0.0 Number of vertices = 9 (should be 9)Number of edges = 13 (should be 13)Edges are OK.Breadth-First Traversal beginning at vertex A: A B D E C G F H I  ActualA B D E C G F H I  ExpectedDepth-First Traversal beginning at vertex A: A B C F E H G D I  ActualA B C F E H G D I  ExpectedFinding the shortest paths from vertex A:The shortest path from A to B is A B and has a length of 1.The shortest path from A to C is A B C and has a length of 2.The shortest path from A to D is A D and has a length of 1.The shortest path from A to E is A E and has a length of 1.The shortest path from A to F is A E F and has a length of 2.The shortest path from A to G is A D G and has a length of 2.The shortest path from A to H is A E H and has a length of 2.The shortest path from A to I is A E F I and has a length of 3.Testing Example 28.26 to create the graph in Figure 28-21:Number of vertices = 3 (should be 3)Number of edges = 2 (should be 2)Done.*/